# 배열
> 배열이란?
- 학생 20명의 국어 성적을 저장하려면? -> 변수 20개 선언
- 학생 500명의 국어 성적을 저장하려면? -> 변수 500개 선언??
- C 언어는 데이터를 그룹으로 묶어서 표현하는 배열(Array)문법을 사용!!


> 배열 선언하고 사용하기
- **자료형**이 같은 변수들을 그룹으로 묶어서 관리할 때 사용
- [](대괄호)를 사용하여 저장 공간을 몇 개 만들 것인지 명시
	- short students[20];
	- 자료형 변수이름 [요소개수]
	- 2바이트 정수형 데이터 20개 = 40바이트

- 데이터를 저장할 요소의 개수는 반드시 **상수**로 작성
- 프로그램 실행 중에 바꿀 수 없음 -> 재컴파일 필요
- 배열은 그룹으로 묶인 데이터를 하나의 변수로 관리


> 배열의 요소에 접근하기
- 변수의 개별 요소에 접근하기 위해서는 변수 이름 뒤에 []를 적고 사용하고 싶은 요소의 색인(Index)을 명시
- 배열 색인은 0부터 시작하여 1씩 증가
- 배열의 요소가 N개라면 색인은 0 ~ N-1까지 사용 가능
	- short students[20];
	student[색인(index)];


> 배열의 특정 요소에 값 대입하기
- [] 기호를 사용하여 특정 요소의 위치를 명시하여 배열의 항목에 값을 저장
	- students[1] = 10;


> 배열 요소에 for문으로 값 대입하기
- 배열의 특정 요소에 값을 대입할 때에는 [] 안에 변수 사용 가능 / 선언할 때는 반드시 **상수**
	- int index = 1;
	- students[index] = 10;

- 배열의 요소에 값을 대입하거나 사용할 때 변수를 사용할 수 있다는 것은 반복문과 같은 제어문을 함께 사용할 수 있다는 뜻
- students 배열의 0번 ~ 4번 요소에 5 저장하기
	- short students[20], i;
	- for (i = 0; i < 5; i++)
	-	student[i] = 5;


> 배열 초기화하기
- 배열로 선언한 지역 변수는 자동 초기화되지 않음 / 전역 변수는 0으로 초기화
- 배열의 각 요소에 일정한 값을 대입하여 초기화한 후 사용
- 일반적으로 초기값 0을 사용
	- short students[20];
	- students[1] = 10;
	- printf("%d %d", students[1], students[2]); // 10 쓰레기값

	- short stduents[20];
	- for (int i = 0; i < 20; i++) students[i] = 0;
	- students[1] = 10;
	- printf("%d %d", students[1], students[2]); // 10 0


> 쉼표를 사용한 배열 초기화 문법
- 배열로 선언한 변수를 {}(중괄호)를 사용하여 일반 변수처럼 초기화하는 방법
	- short students[20] = {0, 0, 0, ....., 0};
	- short students[20] = {0, };

	- short data[5] = {3, } // = {3, 0, 0, 0, 0}과 같음

- 배열의 요소가 많은 경우 0이 아닌 다른 값으로 초기화하고 싶다면 반복문을 사용하는 것이 효과적


> 배열 크기 생략하기
- 배열을 선언할 때 []안의 요소 개수를 생략하고 선언 가능
	- short data[] = {1, 2, 1, 2, 1};
	- 자동으로 5로 할당

- 배열의 특정 요소에 값을 지정할 때는 {} 사용 불가
	- short students[20];
	- students[1] = {5}; // C2059 구문 오류
	- students[2] = {6, 7}; // C2059 구문 오류


> 배열의 요소 값 사용하기
- 배열에 저장된 요소 값을 읽어오거나 요소 값끼리 연산 가능
	- short data[3];
	- data[0] = 2;
	- data[1] = data[0] + 5;
	- data[2] = data[0] + data[1];

	- char data = {1, 2, 3, 4, 5};
	- int result = 0, i;
	- for (i = 0; i < 5; i++)
	-	result = result + data[i];
	- printf("data 배열의 각 요소의 합은 %d입니다.\n", result);


> 배열은 사용자 정의 자료형
- C언어에서 기본으로 제공되는 자료형은 1, 2, 4, 8바이트
- 3바이트 자료형을 사용하고 싶다면?
- 배열은 같은 크기의 메모리를 그룹으로 묶어 새로운 크기의 변수를 만들기 때문에 
- 사용자 정의 자료형(user-defined data type)임
	- char three[3];



# 문자열
> 배열로 문자열 표현하기
- "Hello!"
- 문자열: 문자가 여러 개 있는 것
- 문자열 배열을 사용해서 표현 가능


> 문자열의 길이 정보 표시하기
- C 언어에서 문자를 지정하는데 가장 적합한 자료형이 char형
- char형 변수를 그룹으로 묶어서 관리하는 char 배열을 사용하여 문자열을 저장
- 문자의 끝에 NULL 문자 0(\0)을 추가로 입력하여, 이 배열에 저장된 정보는 문자열이다라고 컴파일러에게 알림
	- char data[6] = {'h', 'a', 'p', 'p', 'y', 0};
	- 문자 개수는 5개이고 끝에 0을 덧붙여야 하므로 배열의 크기는 6

- C 언어의 문자열 상수 표현을 사용하여 간단하게 배열 초기화 가능
	- char data[6] = "Happy"
	- 문자열 끝에 NULL(\0)이 자동으로 포함됨


> 배열의 문자열을 저장하고 출력하기
- printf 함수로 문자열을 출력할 때는 %s를 사용
	- char data[6] = "happy";
	- char ment[] = "C Programming~";
	- printf("%s\n", data);
	- printf("%s\n, ment);


> 지정된 문자열의 길이 구하기
- 배열에 저장된 문자열의 길이를 알기 위해서는 문자열의 끝(0, EOL, End Of Line)을 찾는 코드가 필요
	- char data[6] = "happy";
	- int count = 0;
	- while (data[count] != 0) 
	-	count++;


> 지정된 문자열의 길이 구하기
- 배열에 저장된 문자열의 길이를 구하는 GetStringLength 함수 만들기
- *실습1
- 근데 꼭 만들어서 사용하지 않아도 됨


> 문자열을 다루는 C 내장 함수
- 문자열은 프로그램에서 자주 사용하기 때문에 편하게 사용할 수 있도록 C 언어에서 다양한 함수들을 제공
- str로 시작하는 문자열 표준 함수들은 string.h 파일에서 함수의 원형을 제공
	- strlen = string + length
	- 문자열의 길이를 구하는 문자열 표준 함수

	- strcpy = string + copy
	- 문자열을 복사하는 문자열 표준 함수

	- strcat = string + concatenation
	- 문자열 뒤에 다른 문자열을 덧붙이는 문자열 표준 함수


> 문자열 길이를 구하는 내장 함수: strlen
- strlen(문자열이 저장된 변수 이름)
- *실습2


> 문자열을 복사하고 추가하는 내장 함수: strcpy, strcat
- strcpy(복사해서 저장할 변수 이름, 복사할 기존 변수 이름)
- strcat(기존 문자열이 저장된 변수 이름, 새로 덧붙일 문자열)
- *실습3


> 라이브러리를 직접 만들어보는 것도 동작 원리를 이해하기 좋음
- *실습4
- 배열 인자는 포인터로 배열의 시작 주소로 넘어감
- pass-by-pointer
- 즉, 원본이 수정됨

- 반복문 안에서 함수를 상수 값을 함수로 호출하는 것은 매우 안 좋음
	- bad) for (int i = 0; i < strlen(data); i++)
	- good) int len = strlen(data); for (int i = 0; i < len; i++)

- NULL vs \0
	- NULL == (void*)0 / 널 포인터 상수
	- \0 == 아스키 0 / 문자열 끝을 나타내는 널 문자로 아스키 코드 0



# 2차원 배열
> 1차원 배열로 2차원 형태로 표현하려면?
- 바둑판에 놓여있는 돌의 정보를 저장하려면?
	- 돌 한 개의 정보를 어떤 형식의 변수에 저장할 것인지를 결정
	- 1바이트 char형에 돌 한 개의 정보를 저장 가능
		- 0: 돌이 놓여있지 않은 경우
		- 1: 검은 돌이 놓여있는 경우
		- 2: 흰 돌이 놓여있는 경우

	- 바둑판 전체에 저장할 수 있는 메모리 크기를 결정
		- 19 * 19 = 361개의 돌을 놓을 수 있음
		- char data[361];


> 2차원 배열의 필요성
- 2차원 공간에 있는 한 점은 자신의 위치를 좌표로 나타낼 때 (x, y 축 좌표 값) 형태로 사용
- 바둑판에 놓인 바둑돌의 위치 정보도 2차원 형식의 데이터


> 2차원 배열 선언하기
- 같은 크기의 변수를 나열해서 적는 것이 불편하기 때문에 배열을 사용해서 크기가 같은 변수들끼리 묶어서 사용
- 1차원 배열 5개를 묶으려면?
	- char data1[4], data2[4], data3[4], data4[4], data[5]
	- char data[5][4];

- char data[4][5]가 아닌 char data[5][4]로 적는 이유
	- 연산자 우선 순위 때문! []연산자는 동일한 우선순위를 가질 때 왼쪽에서 오른쪽으로 연산을 수행
	- char (data[5])[4];
	- 1단계: char (data[5])[4]: data[5]라는 배열을 만들겠다
	- 2단계: char (data[5])[4]: data 배열의 각 요소 (data[0], ...)은 char[4] 크기를 가짐

- char data[5][4]를 메모리에 나열하면?
	- [][][][]....[][][][]
	- 우리가 2차원으로 배열을 선언하더라도 
	- 실제 메모리에서는 1차원으로 할당함

- char data[5][4];
	- [5]: 그룹 개수 (Y출)
	- [4]: 그룹당 세부 요소 개수 (X축)
	- 즉, [y][x](y, x)로 봐야함


> 2차원 배열 선언하기 - 행(Y축) 단위로 묶음
- char data[5][4]를 메모리에 나열하면
	- [][][][]....[][][][]
	- 화면상의 좌표가 (x, y)이면 배열에서는 data[y][x]로 사용


> 2차원 배열 선언하기 - 열(X축) 단위로 묶음
- char data[4][5]를 메모리에 나열하면
	- [][][][][].....[][][][][]
	- 화면상의 좌표가 (x, y)이면 배열에서는 data[x][y]로 사용


> 2차원 배열이 실제 메모리에 저장되는 형태
- 컴퓨터가 사용하는 메모리는 2차원 개념을 제공하지 않음
- 배열 문법으로 선언된 메모리는 1차원 형태로 메모리에 저장
- 소스 코드에서 배열을 2차원 형식으로 사용할 수 있는 이유?
	- 배열 문법을 사용하여 논리적으로 재구성한 2차원 데이터 형식
	- 수학적으로 계산을 할 수 있어야함 (1차원 <-> 2차원)


> 2차원 배열 초기화하기
- char temp1[3] = {1, 2, 3};
- char temp2[3] = {4, 5, 6};

- char temp[2][3] = {{1, 2, 3}, {4, 5, 6}};


> 2차원 데이터를 1차원 데이터로 변환하기
- 5행 4열 크기로 줄인 바둑판에서 1행 1열부터 순서대로 돌을 9개 놓음
- 돌을 놓을 때마다 0번부터 1씩 증가시키면서 돌에 번호를 적어둠
- y축 구하기: (행 번호 - 1) * 열 개수
- x축 구하기: ((행 번호 - 1) * 열 개수) + 열번호 - 1


> 1차원 데이터를 2차원 데이터로 변환하기
- 1차원 데이터를 2차원 데이터로 변환하려면 행 번호와 열 번호를 계산해야 함
- 행 번호를 찾는 방법
	- (돌 번호 / 열 개수) + 1

- 열 번호를 찾는 방법
	- (돌 번호 % 열 개수) + 1


> 1차원 vs 2차원
- 결국 메모리에 올라가는 것은 같음
- char temp[M][N];
- char test[L];

- test[a] - temp[a / N][a % N]
- temp[b][c] - test[b * N + c]


> 1차원 배열과 2차원 배열의 차이
- 바둑판을 연산할 때, 1차원이 편할까? 2차원이 편할까? (사용자 관점에서)
- 당연히 2차원이 편함
- 수학적 연산을 통해서 할 수도 있음
